import websocket
import json
import threading
import time
from fastapi import FastAPI
import uvicorn
import rel

app = FastAPI()

# Configura√ß√£o Quotex
QUOTEX_WS_URL = "wss://ws.quotex.io/socket.io/"
EMAIL = "seu_email@example.com"
PASSWORD = "sua_senha"

# Dados em tempo real
current_prices = {}
current_candles = {}
ws_connection = None

def on_message(ws, message):
    """Processar mensagens do WebSocket"""
    try:
        data = json.loads(message)
        
        if "asset" in data and "price" in data:
            asset = data["asset"]
            current_prices[asset] = {
                "price": data["price"],
                "timestamp": time.time()
            }
            print(f"‚úÖ Pre√ßo atualizado: {asset} = {data['price']}")
        
        if "candle" in data:
            asset = data["candle"]["asset"]
            if asset not in current_candles:
                current_candles[asset] = []
            
            current_candles[asset].append({
                "open": data["candle"]["open"],
                "high": data["candle"]["high"],
                "low": data["candle"]["low"],
                "close": data["candle"]["close"],
                "volume": data["candle"].get("volume", 0),
                "time": data["candle"]["time"]
            })
            
            if len(current_candles[asset]) > 100:
                current_candles[asset] = current_candles[asset][-100:]
                
    except Exception as e:
        print(f"Erro: {e}")

def on_error(ws, error):
    print(f"‚ùå Erro WebSocket: {error}")

def on_close(ws, close_status_code, close_msg):
    print(f"‚ö†Ô∏è Conex√£o fechada: {close_status_code}")
    print("üîÑ Tentando reconectar em 5 segundos...")
    time.sleep(5)
    connect_websocket()

def on_open(ws):
    print("‚úÖ Conectado ao WebSocket da Quotex!")
    
    auth_message = {
        "type": "auth",
        "email": EMAIL,
        "password": PASSWORD
    }
    ws.send(json.dumps(auth_message))
    
    assets = ["EURUSD", "GBPUSD", "USDJPY", "BTCUSD"]
    for asset in assets:
        subscribe_message = {
            "type": "subscribe",
            "asset": asset,
            "period": 60
        }
        ws.send(json.dumps(subscribe_message))
        print(f"üìä Assinado: {asset}")

def connect_websocket():
    global ws_connection
    
    ws_connection = websocket.WebSocketApp(
        QUOTEX_WS_URL,
        on_open=on_open,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close
    )
    
    ws_connection.run_forever(
        dispatcher=rel,
        reconnect=5
    )
    rel.signal(2, rel.abort)
    rel.dispatch()

@app.on_event("startup")
async def startup():
    ws_thread = threading.Thread(target=connect_websocket, daemon=True)
    ws_thread.start()
    print("üöÄ WebSocket iniciado em background")

@app.get("/price/{asset}")
async def get_price(asset: str):
    if asset in current_prices:
        return {
            "asset": asset,
            "price": current_prices[asset]["price"],
            "timestamp": current_prices[asset]["timestamp"]
        }
    return {"error": "Asset not found"}

@app.get("/candles/{asset}")
async def get_candles(asset: str):
    if asset in current_candles:
        return {
            "asset": asset,
            "candles": current_candles[asset]
        }
    return {"error": "Asset not found"}

@app.get("/status")
async def get_status():
    return {
        "connected": ws_connection is not None,
        "assets_tracking": list(current_prices.keys()),
        "total_candles": sum(len(v) for v in current_candles.values())
    }

@app.get("/health")
async def health():
    return {"status": "ok"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)